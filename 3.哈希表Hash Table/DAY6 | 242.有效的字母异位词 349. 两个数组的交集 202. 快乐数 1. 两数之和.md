# 哈希表理论基础 
文章讲解：https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html  
**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**  
### **哈希表的实现形式**：   
#### 1. 数组
优点：  
直观简单： 数组作为哈希表的实现是一种直观简单的方式。通过使用数组的索引，可以直接访问哈希表中的元素，这样的实现更容易理解和实现。  
随机访问： 数组允许在常量时间内进行随机访问，即通过索引直接访问元素。这使得在哈希表中查找、插入和删除元素的平均时间复杂度为 O(1)。  
缺点：  
**空间浪费**： 数组作为哈希表实现的一个缺点是可能存在空间浪费。如果哈希表中的元素不是很密集，即数组的大小远大于实际元素的数量，可能会浪费一定的空间。  
碰撞处理： 哈希表中可能会发生碰撞（两个不同的键映射到相同的索引位置），而数组实现通常需要使用一些技术来处理碰撞。  
**动态调整大小的复杂性**： 当哈希表中元素的数量变化时，可能需要动态调整数组的大小，这可能涉及重新哈希和重新分配内存等复杂的操作，以确保哈希表的性能仍然良好。  
#### 2. set 集合
优点：  
不需要处理碰撞： 集合本质上是一个没有重复元素的数据结构，因此不会出现碰撞（两个不同的键映射到相同的索引位置）的问题。    
直观简单： 集合提供了直观简单的接口，可以方便地执行添加、删除和查找操作。这种实现通常更易于理解和使用。  
无空间浪费： 由于集合是一个不包含重复元素的数据结构，不会出现数组中可能存在的空间浪费问题。集合的大小直接反映实际元素的数量。  
缺点：  
空间效率： 集合实现可能在空间效率上不如数组。由于集合需要存储额外的数据结构来维护元素的唯一性，可能会导致一些额外的空间开销。  
**无法支持关联值**： 集合通常只包含键而不包含关联的值。      
**不支持按顺序遍历**： 集合不保留元素的插入顺序，因此无法按照插入顺序来遍历元素。   

#### 3. map 映射
优点：  
**关联键值对**： 映射允许存储关联的键值对，这使得它适用于需要维护键和相应值之间关系的场景。   
直观简单： 映射提供了直观简单的接口，可以方便地执行添加、删除和查找操作。这种实现通常更易于理解和使用。  
动态扩展： 映射可以动态扩展，即在运行时可以不断地添加新的键值对，而无需预先指定容量。  
缺点：  
空间效率： 映射可能在空间效率上不如数组，因为它需要存储键和值。特别是在存储大量数据时，可能会产生相对较大的内存开销。  
**不保持顺序**： 映射通常不保持键值对的插入顺序。如果需要按照插入顺序遍历键值对，可能需要考虑其他实现方式。  
复杂性： 由于映射需要存储键值对，可能在一些场景下引入额外的复杂性。对于只需要键的情况，使用集合可能更为简单  

**冲突解决**： 由于哈希函数的映射不是唯一的，可能会出现两个不同的键映射到相同的桶的情况，称为哈希冲突。  
Python使用**开放寻址法**和**链地址法**等方法来解决冲突。  

# 242.有效的字母异位词
题目链接：https://leetcode.cn/problems/valid-anagram/description/  
文章讲解/视频讲解： https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html  
### ASCII编码
ASCII（American Standard Code for Information Interchange）是一种将字符映射到数字的编码标准。  
它包含128个字符，包括英文字母（大写和小写）、数字、标点符号以及一些控制字符。  
每个字符都有一个唯一的ASCII码，用于在计算机中表示和存储。下面是一些常见字符的ASCII码：  
    
大写字母 A 到 Z 的ASCII码是 65 到 90。  
小写字母 a 到 z 的ASCII码是 97 到 122。  
数字 0 到 9 的ASCII码是 48 到 57。  
一些常见标点符号的ASCII码：句号.是46，逗号,是44，感叹号!是33，等等。  
  
这样的编码方案使得计算机能够理解和处理文本数据。  
在Python中，可以使用 $ord()$ 函数获取字符的ASCII码，例如ord("a")返回97。  
相反，使用 $chr()$ 函数可以将ASCII码转换为对应的字符。  
  
**第一思路**：存储第一个词里字母的出现次数，对应第二个词里的出现次数是否一样/能否对应。但是不知道具体实现方法  
```Python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in s:
            #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[ord(i) - ord("a")] += 1
        for i in t:
            record[ord(i) - ord("a")] -= 1
        for i in range(26):
            if record[i] != 0:
                #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return False
        return True
```


# 349. 两个数组的交集
题目链接:https://leetcode.cn/problems/intersection-of-two-arrays/  
文章讲解/视频讲解：https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html  
### 创建set
1. 使用花括号 ${}$ 
```Python
my_set = {1, 2, 3, 4, 5}
print(my_set)
```
  
2.  使用 $set()$ 构造函数  
```Python
my_list = [1, 2, 3, 4, 5]
my_set = set(my_list)
print(my_set)
```
**思路**：创造哈希表， table[数值] = 出现次数  
```Python
table = {}
for num in nums1:
    table[num] = table.get(num, 0) + 1
```

# 202. 快乐数
题目链接:https://leetcode.cn/problems/happy-number/  
文章讲解：https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html    
**第一思路**：个位数只有 $0-9$ ,对应的平方个位数是 $0, 1, 4, 9, 6, 5$, 需要成对出现  
**问题**：但是个位数的转换是单向的  
**思路**： 题目中说只会有两种结果：变成1（快乐书） 和 无限循环（重复出现）  
把之前出现过的和存储起来，如果重复出现了就说明进入循环，不是快乐数  
```Python
def get_sum(self,n: int) -> int:
    # 求一个数字每个位置上的数字的平方和
    new_num = 0
    while n:
        n, r = divmod(n, 10)
        new_num += r ** 2
    return new_num
```



# 1. 两数之和  
题目链接：https://leetcode.cn/problems/two-sum/  
文章讲解/视频讲解：https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html  


